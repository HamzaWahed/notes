<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>275</fr:anchor><fr:addr
type="user">hamzawahed</fr:addr><fr:route>hamzawahed.xml</fr:route><fr:title
text="Hamza Wahed">Hamza Wahed</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta
name="position">Student</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Contributions">Contributions</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>276</fr:anchor><fr:addr
type="user">hzw-0009</fr:addr><fr:route>hzw-0009.xml</fr:route><fr:title
text="G  has a vertex cover of size  k iff G - (H {} I) has a vertex cover of size k - |H|"><fr:tex
display="inline"><![CDATA[G ]]></fr:tex> has a vertex cover of size <fr:tex
display="inline"><![CDATA[\leq  k]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[G - (H \cup {} I)]]></fr:tex> has a vertex cover of size <fr:tex
display="inline"><![CDATA[k - |H|]]></fr:tex></fr:title><fr:taxon>Claim</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="hamzawahed.xml"
addr="hamzawahed"
title="Hamza Wahed">Hamza Wahed</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[G - (H \cup {} I)]]></fr:tex> has a vertex cover of size at most <fr:tex
display="inline"><![CDATA[k - |H|]]></fr:tex>
    Since <fr:tex
display="inline"><![CDATA[N(I) \subseteq  H]]></fr:tex>, that implies that by including all the vertices in
    <fr:tex
display="inline"><![CDATA[H ]]></fr:tex>, we can cover all the remaining edges in <fr:tex
display="inline"><![CDATA[G ]]></fr:tex>.

    Suppose that <fr:tex
display="inline"><![CDATA[G ]]></fr:tex> has a vertex cover <fr:tex
display="inline"><![CDATA[C ]]></fr:tex> of size at most <fr:tex
display="inline"><![CDATA[k ]]></fr:tex>. As <fr:tex
display="inline"><![CDATA[G[H,I]]]></fr:tex> has a
    matching of size <fr:tex
display="inline"><![CDATA[|H|]]></fr:tex>, we know that <fr:tex
display="inline"><![CDATA[C]]></fr:tex> must contain the endpoints of any such
    matching to be able to cover the edges between <fr:tex
display="inline"><![CDATA[I ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[H ]]></fr:tex>. Therefore, <fr:tex
display="inline"><![CDATA[G - (H     \cup {} I)]]></fr:tex> must then be covered using at most <fr:tex
display="inline"><![CDATA[k - |H|]]></fr:tex> vertices.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>278</fr:anchor><fr:addr
type="user">hzw-000A</fr:addr><fr:route>hzw-000A.xml</fr:route><fr:title
text="Crowns">Crowns</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="hamzawahed.xml"
addr="hamzawahed"
title="Hamza Wahed">Hamza Wahed</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A crown structure <fr:tex
display="inline"><![CDATA[(H,I)]]></fr:tex> looks like the following image:</fr:p><fr:ul><fr:li><fr:tex
display="inline"><![CDATA[I ]]></fr:tex> is an independent set</fr:li>

  <fr:li><fr:tex
display="inline"><![CDATA[N(I) \subseteq  H]]></fr:tex></fr:li>

  <fr:li><fr:tex
display="inline"><![CDATA[G[H,I]$ has a matching of size $|H|]]></fr:tex></fr:li></fr:ul><fr:figure><html:img
xmlns:html="http://www.w3.org/1999/xhtml"
src="crown.png" />
    <fr:figcaption>A crown structure</fr:figcaption></fr:figure><fr:figure><html:img
xmlns:html="http://www.w3.org/1999/xhtml"
src="not-crown.png" />
    <fr:figcaption>Not a crown as <fr:tex
display="inline"><![CDATA[G[H,I]]]></fr:tex> does not have a matching of size <fr:tex
display="inline"><![CDATA[|H|]]></fr:tex></fr:figcaption></fr:figure></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>280</fr:anchor><fr:addr
type="user">hzw-0008</fr:addr><fr:route>hzw-0008.xml</fr:route><fr:title
text="Vertex Cover via Crown Reduction">Vertex Cover via Crown Reduction</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="hamzawahed.xml"
addr="hamzawahed"
title="Hamza Wahed">Hamza Wahed</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We use the concept of <fr:link
type="local"
href="hzw-000A.xml"
addr="hzw-000A"
title="Crowns">crowns</fr:link>.

    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>243</fr:anchor><fr:addr
type="user">hzw-0009</fr:addr><fr:route>hzw-0009.xml</fr:route><fr:title
text="G  has a vertex cover of size  k iff G - (H {} I) has a vertex cover of size k - |H|"><fr:tex
display="inline"><![CDATA[G ]]></fr:tex> has a vertex cover of size <fr:tex
display="inline"><![CDATA[\leq  k]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[G - (H \cup {} I)]]></fr:tex> has a vertex cover of size <fr:tex
display="inline"><![CDATA[k - |H|]]></fr:tex></fr:title><fr:taxon>Claim</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>14</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="hamzawahed.xml"
addr="hamzawahed"
title="Hamza Wahed">Hamza Wahed</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[G - (H \cup {} I)]]></fr:tex> has a vertex cover of size at most <fr:tex
display="inline"><![CDATA[k - |H|]]></fr:tex>
    Since <fr:tex
display="inline"><![CDATA[N(I) \subseteq  H]]></fr:tex>, that implies that by including all the vertices in
    <fr:tex
display="inline"><![CDATA[H ]]></fr:tex>, we can cover all the remaining edges in <fr:tex
display="inline"><![CDATA[G ]]></fr:tex>.

    Suppose that <fr:tex
display="inline"><![CDATA[G ]]></fr:tex> has a vertex cover <fr:tex
display="inline"><![CDATA[C ]]></fr:tex> of size at most <fr:tex
display="inline"><![CDATA[k ]]></fr:tex>. As <fr:tex
display="inline"><![CDATA[G[H,I]]]></fr:tex> has a
    matching of size <fr:tex
display="inline"><![CDATA[|H|]]></fr:tex>, we know that <fr:tex
display="inline"><![CDATA[C]]></fr:tex> must contain the endpoints of any such
    matching to be able to cover the edges between <fr:tex
display="inline"><![CDATA[I ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[H ]]></fr:tex>. Therefore, <fr:tex
display="inline"><![CDATA[G - (H     \cup {} I)]]></fr:tex> must then be covered using at most <fr:tex
display="inline"><![CDATA[k - |H|]]></fr:tex> vertices.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

    The goal is to find a large crown <fr:tex
display="inline"><![CDATA[(H,I) ]]></fr:tex>, so we only use the reduction rule
    once.  shows that <fr:tex
display="inline"><![CDATA[G - (H \cup {} I)]]></fr:tex> contains at most
    <fr:tex
display="inline"><![CDATA[3k ]]></fr:tex> vertices, and otherwise it's not a no-instance.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>282</fr:anchor><fr:addr
type="user">hzw-0002</fr:addr><fr:route>hzw-0002.xml</fr:route><fr:title
text="{C}  is an {H}_n  approximation of an
optimal set cover"><fr:tex
display="inline"><![CDATA[\mathcal {C} ]]></fr:tex> is an <fr:tex
display="inline"><![CDATA[\mathcal {H}_n ]]></fr:tex> approximation of an
optimal set cover</fr:title><fr:taxon>Corollary</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>13</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="hamzawahed.xml"
addr="hamzawahed"
title="Hamza Wahed">Hamza Wahed</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathcal {C}^* ]]></fr:tex> be an optimal set cover. Then, we have:
  <fr:tex
display="block"><![CDATA[     \begin {align*}         c(\mathcal {C}) &= \sum _{ e \in  U } p(e) \\         &= \mathcal {H}_{ n } \sum _{ e \in  U }         \frac {p(e)}{\mathcal {H}_{ n }} \\         &\leq  \mathcal {H}_{ n } \cdot  c(\mathcal {C}^*)     \end {align*}   ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>284</fr:anchor><fr:addr
type="user">hzw-0003</fr:addr><fr:route>hzw-0003.xml</fr:route><fr:title
text="{Y} = {p(e)}{{H}_{ n }} is a feasible dual solution "><fr:tex
display="inline"><![CDATA[\hat {y} = \frac {p(e)}{\mathcal {H}_{ n }}]]></fr:tex> is a feasible dual solution </fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>13</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="hamzawahed.xml"
addr="hamzawahed"
title="Hamza Wahed">Hamza Wahed</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We only need to show that the constraint
  <fr:tex
display="block"><![CDATA[     \sum _{ e \in  S } y_{ e } \geq  c_{ S } \quad  \forall  S \in      \mathcal {S}   ]]></fr:tex> 
  is satisfied, as by definition, <fr:tex
display="inline"><![CDATA[y_{ e } \geq  0 ]]></fr:tex>. We start by
  ordering the elements <fr:tex
display="inline"><![CDATA[\{ e_1, \ldots , e_k \}]]></fr:tex> as they are covered. 
  We claim that <fr:tex
display="inline"><![CDATA[p(e_{ i }) \leq  \frac {c(S)}{k-i+1} ]]></fr:tex>.</fr:p><fr:p>We show why <fr:tex
display="inline"><![CDATA[p(e_{ i }) \leq  \frac {c(S)}{k-i+1} ]]></fr:tex>. Let <fr:tex
display="inline"><![CDATA[S' ]]></fr:tex> be
  the set used to cover <fr:tex
display="inline"><![CDATA[e_{ i } ]]></fr:tex>. Therefore, <fr:tex
display="inline"><![CDATA[S' ]]></fr:tex> must be minimal
  cost set that the algorithm found to cover <fr:tex
display="inline"><![CDATA[e_{ i } ]]></fr:tex>. Before
  adding <fr:tex
display="inline"><![CDATA[S' ]]></fr:tex> to <fr:tex
display="inline"><![CDATA[\mathcal {C} ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[e_{ i }, \ldots , e_{ k } ]]></fr:tex> were
  uncovered. By defintion, if <fr:tex
display="inline"><![CDATA[S ]]></fr:tex> were some set that covered <fr:tex
display="inline"><![CDATA[e_{ i   } ]]></fr:tex>, then the cost of covering <fr:tex
display="inline"><![CDATA[e_{ i } ]]></fr:tex> would be:
  <fr:tex
display="block"><![CDATA[     \frac {c(S)}{k-i+1}   ]]></fr:tex> 
  where the <fr:tex
display="inline"><![CDATA[+1 ]]></fr:tex> is because we haven't added <fr:tex
display="inline"><![CDATA[e_{ i } ]]></fr:tex> yet. Since
  <fr:tex
display="inline"><![CDATA[S' ]]></fr:tex> is the minimal cost set it follows that:
  <fr:tex
display="block"><![CDATA[     c(S') \leq  \frac {c(S)}{k-i+1}   ]]></fr:tex></fr:p><fr:p>Using the above claim, we see that:
  <fr:tex
display="block"><![CDATA[     \begin {align*}       \sum _{ i=1 }^{ k } p(e_{ i }) &\leq  \sum _{ i=1 }^{ k } \frac {c(S)}{k-i+1} \\       &= c(S) \sum _{ i=1 }^{ k } \frac {1}{i} \\       &= c(S) \cdot  \mathcal {H}_{ k }     \end {align*}   ]]></fr:tex> 

  Therefore, summing over all values of <fr:tex
display="inline"><![CDATA[\hat {y} ]]></fr:tex> gives us:
  <fr:tex
display="block"><![CDATA[     \begin {align*}       \sum _{ i=1 }^{ k } y_{ e_i } &= \sum _{ i=1 }^{ k } p(e_{ i })       \frac {1}{\mathcal {H}_{ n }} \\       &\leq  \sum _{ i=1 }^{ k } c(S) \frac {\mathcal {H}_{ k       }}{\mathcal {H}_{ n }} \\       &\leq  c(S)     \end {align*}   ]]></fr:tex> 

  where <fr:tex
display="inline"><![CDATA[\frac {\mathcal {H}_{ k }}{\mathcal {H}_{ n }} \leq  1 ]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>286</fr:anchor><fr:addr
type="user">hzw-0005</fr:addr><fr:route>hzw-0005.xml</fr:route><fr:title
text="Dual Fitting">Dual Fitting</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>13</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="hamzawahed.xml"
addr="hamzawahed"
title="Hamza Wahed">Hamza Wahed</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We know that the optimal solution of the LP relaxation of an ILP is 
  a lower bound of the optimal solution of the ILP. We also know that
  the objective function value of any dual solution is at most the
  optimal solution of the primal LP. Therefore, we have:
  <fr:tex
display="block"><![CDATA[     \text {obj(dual)} \leq  \text {OPT(LP relaxation)} \leq  \text {OPT(ILP)}   ]]></fr:tex> 

  Given an integral primal solution <fr:tex
display="inline"><![CDATA[P ]]></fr:tex>, the goal is to find a
  feasible dual solution <fr:tex
display="inline"><![CDATA[D ]]></fr:tex> such that:
  <fr:tex
display="block"><![CDATA[     \text {obj(P)} \leq  c \cdot  \text {obj(D)}   ]]></fr:tex></fr:p><fr:figure><html:img
xmlns:html="http://www.w3.org/1999/xhtml"
src="dual-fit.png" />
    <fr:figcaption>dual fitting</fr:figcaption></fr:figure></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>288</fr:anchor><fr:addr
type="user">hzw-0004</fr:addr><fr:route>hzw-0004.xml</fr:route><fr:title
text="If all sets in {S}  have size at most k , then
the greedy set cover algorithm finds an O( k)-approximation of
an optimal set cover">If all sets in <fr:tex
display="inline"><![CDATA[\mathcal {S} ]]></fr:tex> have size at most <fr:tex
display="inline"><![CDATA[k ]]></fr:tex>, then
the greedy set cover algorithm finds an <fr:tex
display="inline"><![CDATA[O(\lg  k)]]></fr:tex>-approximation of
an optimal set cover</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>13</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="hamzawahed.xml"
addr="hamzawahed"
title="Hamza Wahed">Hamza Wahed</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The proof follows immediately from <fr:link
type="local"
href="hzw-0003.xml"
addr="hzw-0003"
title="{Y} = {p(e)}{{H}_{ n }} is a feasible dual solution ">Lemma</fr:link> by substituting
  <fr:tex
display="inline"><![CDATA[\mathcal {H}_{ k } ]]></fr:tex> instead of <fr:tex
display="inline"><![CDATA[\mathcal {H}_{ n } ]]></fr:tex>, and both
  numerator and denominator cancel out to give <fr:tex
display="inline"><![CDATA[1 ]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>290</fr:anchor><fr:addr
type="user">hzw-0006</fr:addr><fr:route>hzw-0006.xml</fr:route><fr:title
text="Primal Dual Set Cover computes an f -approximation of an
optimal set cover">Primal Dual Set Cover computes an <fr:tex
display="inline"><![CDATA[f ]]></fr:tex>-approximation of an
optimal set cover</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>13</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="hamzawahed.xml"
addr="hamzawahed"
title="Hamza Wahed">Hamza Wahed</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="inline"><![CDATA[f ]]></fr:tex> is defined to be the maximum number of sets that an element is
  contained in. In other words, 
  <fr:tex
display="block"><![CDATA[     f = \max _{ e \in  U } |\{ S \in  \mathcal {S} | e \in  S \}|   ]]></fr:tex> 
  We use primal dual schema to obtain an algorithm for the set cover
  problem. The primal schema is unchanged. Note that the primal is an
  ILP, so <fr:tex
display="inline"><![CDATA[x_{ S } \in  \{ 0,1 \} ]]></fr:tex>. If <fr:tex
display="inline"><![CDATA[x_{ S } = 1 ]]></fr:tex>, then we
  require the set <fr:tex
display="inline"><![CDATA[S ]]></fr:tex> to be "tight", that is, it has no remaining
  capacity. 
  <fr:tex
display="block"><![CDATA[     x_{ S } = 0 \text { or } \sum _{ e \in  U } y_{ e } \leq  w(S)   ]]></fr:tex> 
  The dual schema is updated as follows:
  <fr:tex
display="block"><![CDATA[     y_{ e } = 0 \text { or } \sum _{ e \in  S } x_{ S } \leq  f    ]]></fr:tex> 

  Note that <fr:tex
display="inline"><![CDATA[\sum _{ e \in  S } x_{ S } \leq  f]]></fr:tex> is always satisfied,
  since if <fr:tex
display="inline"><![CDATA[e ]]></fr:tex> occurs in all sets, then <fr:tex
display="inline"><![CDATA[x_{ S } = 1 ]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[S   \in  \mathcal {S}]]></fr:tex>, but that can only be equal to <fr:tex
display="inline"><![CDATA[f ]]></fr:tex> as per the
  definition.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>267</fr:anchor><fr:addr
type="user">hzw-0007</fr:addr><fr:route>hzw-0007.xml</fr:route><fr:title
text="Primal Dual Schema Algorithm for Set Cover">Primal Dual Schema Algorithm for Set Cover</fr:title><fr:taxon>Algorithm</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>13</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="hamzawahed.xml"
addr="hamzawahed"
title="Hamza Wahed">Hamza Wahed</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Start by initialzing <fr:tex
display="inline"><![CDATA[\mathcal {C} = \emptyset  ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\hat {y}_{ e }   = 0 ]]></fr:tex>
  for all <fr:tex
display="inline"><![CDATA[e \in  U ]]></fr:tex>. While there exists an element <fr:tex
display="inline"><![CDATA[e \in  U ]]></fr:tex> such
  that <fr:tex
display="inline"><![CDATA[e ]]></fr:tex> is not covered by <fr:tex
display="inline"><![CDATA[\mathcal {C} ]]></fr:tex>, we let <fr:tex
display="inline"><![CDATA[\delta  ]]></fr:tex> be:
  <fr:tex
display="block"><![CDATA[     \delta  = \min _{ e \in  S } \left (w(S) - \sum _{ f \in  S } \hat {y}_{ f }     \right )   ]]></fr:tex> 
  We know that <fr:tex
display="inline"><![CDATA[w(S) \geq  \sum _{ f \in  S } \hat {y}_{ f } ]]></fr:tex> as
  <fr:tex
display="inline"><![CDATA[\hat {y} ]]></fr:tex> is currently a feasible dual solution. Then, we update
  <fr:tex
display="inline"><![CDATA[\hat {y}_{ e } ]]></fr:tex> to be:
  <fr:tex
display="block"><![CDATA[     \hat {y}_{ e } = \hat {y}_{ e } + \delta    ]]></fr:tex> 
  Once all elements of <fr:tex
display="inline"><![CDATA[U ]]></fr:tex> are covered by <fr:tex
display="inline"><![CDATA[\mathcal {C} ]]></fr:tex>, we return
  <fr:tex
display="inline"><![CDATA[\mathcal {C} ]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>292</fr:anchor><fr:addr
type="user">hzw-0007</fr:addr><fr:route>hzw-0007.xml</fr:route><fr:title
text="Primal Dual Schema Algorithm for Set Cover">Primal Dual Schema Algorithm for Set Cover</fr:title><fr:taxon>Algorithm</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>13</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="hamzawahed.xml"
addr="hamzawahed"
title="Hamza Wahed">Hamza Wahed</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Start by initialzing <fr:tex
display="inline"><![CDATA[\mathcal {C} = \emptyset  ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\hat {y}_{ e }   = 0 ]]></fr:tex>
  for all <fr:tex
display="inline"><![CDATA[e \in  U ]]></fr:tex>. While there exists an element <fr:tex
display="inline"><![CDATA[e \in  U ]]></fr:tex> such
  that <fr:tex
display="inline"><![CDATA[e ]]></fr:tex> is not covered by <fr:tex
display="inline"><![CDATA[\mathcal {C} ]]></fr:tex>, we let <fr:tex
display="inline"><![CDATA[\delta  ]]></fr:tex> be:
  <fr:tex
display="block"><![CDATA[     \delta  = \min _{ e \in  S } \left (w(S) - \sum _{ f \in  S } \hat {y}_{ f }     \right )   ]]></fr:tex> 
  We know that <fr:tex
display="inline"><![CDATA[w(S) \geq  \sum _{ f \in  S } \hat {y}_{ f } ]]></fr:tex> as
  <fr:tex
display="inline"><![CDATA[\hat {y} ]]></fr:tex> is currently a feasible dual solution. Then, we update
  <fr:tex
display="inline"><![CDATA[\hat {y}_{ e } ]]></fr:tex> to be:
  <fr:tex
display="block"><![CDATA[     \hat {y}_{ e } = \hat {y}_{ e } + \delta    ]]></fr:tex> 
  Once all elements of <fr:tex
display="inline"><![CDATA[U ]]></fr:tex> are covered by <fr:tex
display="inline"><![CDATA[\mathcal {C} ]]></fr:tex>, we return
  <fr:tex
display="inline"><![CDATA[\mathcal {C} ]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>294</fr:anchor><fr:addr
type="user">hzw-0001</fr:addr><fr:route>hzw-0001.xml</fr:route><fr:title
text="Nix Flakes">Nix Flakes</fr:title><fr:taxon>Concept</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="hamzawahed.xml"
addr="hamzawahed"
title="Hamza Wahed">Hamza Wahed</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A flake is a file system tree that contains a file called <fr:code>flake.nix</fr:code></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>296</fr:anchor><fr:addr
type="user">index</fr:addr><fr:route>index.xml</fr:route><fr:title
text="Hamza Wahed">Hamza Wahed</fr:title><fr:authors><fr:author><fr:link
type="local"
href="hamzawahed.xml"
addr="hamzawahed"
title="Hamza Wahed">Hamza Wahed</fr:link></fr:author></fr:authors><fr:meta
name="author">false</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>I am a senior at Dalhousie University, doing research in Fixed-Parameter
    Tractable Algorithms and Fundamental Data Structures. In addition to my core
    work, I am also deeply interested in Programming Languages, Compilers, and
    Category Theory.</fr:p><fr:p>This website is a forest where I organize my thoughts, create notes on the
    topics I'm currently exploring and create links between related concepts.
    These notes are intended for my own use, so they may not always be easily
    understood by others. You can search my notes using <fr:code>Cmd + k</fr:code>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>